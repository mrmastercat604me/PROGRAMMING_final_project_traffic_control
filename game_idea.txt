Flow Free-style Puzzles:
Gameplay:
Create grids where players connect pairs of tiles of the same color with non-intersecting paths.

Challenge:
Procedurally generate puzzles where the paths should be challenging,
but not too predictable. The key is ensuring that multiple paths can exist,
but some are blocked or forced to take certain turns.

What you can use:
A* pathfinding can help ensure paths are solvable.
Random obstacles and varying grid sizes can make it more interesting.

Labyrinth Solver:
Gameplay:
Generate random mazes, and the player’s task is to find a path from start to finish.

Challenge:
You can create time challenges, shifting mazes,
or have “rooms” that need to be solved in sequence.

What you can use:
A* can help the AI or the player find a path.
Adding environmental elements like walls that shift or traps can create more engaging puzzles.

What if we combine them?
You could design a labyrinth-style puzzle where the grid is filled with flow-style paths.
The player could be tasked with solving multiple path pairs in the maze, making it more engaging.

The maze could have parts that are already solved,
or maybe parts that randomly block paths and change with time.

As the player progresses, the puzzle could shift or have new rules added—for example,
you can make paths block certain tiles temporarily.



'''
def find_isolated_regions(grid):
    """Find all isolated regions of path tiles in the grid using BFS (with lists)."""
    visited = set()
    regions = []

    for row in grid.grid:
        for tile in row:
            if tile.type == 'path' and (tile.x, tile.y) not in visited:
                # BFS to discover the full region
                region = set()
                queue = [(tile.x, tile.y)]  # Use list as the queue
                visited.add((tile.x, tile.y))
                while queue:
                    x, y = queue.pop(0)  # Remove the first element (queue behavior)
                    region.add((x, y))
                    current_tile = grid.get_tile_with_index(x, y)
                    for neighbour in grid.get_neighbours(current_tile, only_type='path'):
                        coord = (neighbour.x, neighbour.y)
                        if coord not in visited:
                            visited.add(coord)
                            queue.append(coord)  # Add to the queue (list)
                regions.append(region)
    
    return regions

def find_closest_regions(region1, region2):
    """Find the closest path between two regions."""
    min_distance = float('inf')
    closest_pair = None

    for (x1, y1) in region1:
        for (x2, y2) in region2:
            distance = abs(x1 - x2) + abs(y1 - y2)  # Manhattan distance
            if distance < min_distance:
                min_distance = distance
                closest_pair = ((x1, y1), (x2, y2))
    
    return closest_pair

def create_path(grid, start, end):
    """Create a path between two tiles (start and end)."""
    # Implementing a simple line-drawing method (could be more sophisticated)
    x1, y1 = start
    x2, y2 = end

    # Use a simple vertical or horizontal line to connect the tiles
    path_tiles = []
    
    # Horizontal path
    if x1 == x2:
        for y in range(min(y1, y2), max(y1, y2) + 1):
            tile = grid.get_tile_with_index(x1, y)
            tile.type = 'path'
            path_tiles.append((x1, y))
    
    # Vertical path
    elif y1 == y2:
        for x in range(min(x1, x2), max(x1, x2) + 1):
            tile = grid.get_tile_with_index(x, y1)
            tile.type = 'path'
            path_tiles.append((x, y1))

    # Diagonal path (simple version, but we could improve)
    else:
        dx = 1 if x2 > x1 else -1
        dy = 1 if y2 > y1 else -1
        x, y = x1, y1
        while x != x2 and y != y2:
            tile = grid.get_tile_with_index(x, y)
            tile.type = 'path'
            path_tiles.append((x, y))
            x += dx
            y += dy
        # Ensure we reach the endpoint
        tile = grid.get_tile_with_index(x2, y2)
        tile.type = 'path'
        path_tiles.append((x2, y2))
    
    return path_tiles

def connect_isolated_regions(grid):
    """Connect isolated regions of path tiles to make the grid fully connected."""
    regions = find_isolated_regions(grid)

    while len(regions) > 1:
        # Find the closest pair of regions
        closest_pair = None
        min_distance = float('inf')
        region1, region2 = None, None

        for i, r1 in enumerate(regions):
            for j, r2 in enumerate(regions):
                if i >= j:
                    continue
                pair = find_closest_regions(r1, r2)
                if pair:
                    (x1, y1), (x2, y2) = pair
                    distance = abs(x1 - x2) + abs(y1 - y2)
                    if distance < min_distance:
                        min_distance = distance
                        closest_pair = pair
                        region1, region2 = r1, r2
        
        # Now create a path between the closest regions
        if closest_pair:
            start, end = closest_pair
            create_path(grid, start, end)

            # Merge the two regions into one
            new_region = region1.union(region2)
            regions.remove(region1)
            regions.remove(region2)
            regions.append(new_region)

    return grid  # Return the modified grid after connecting regions

'''