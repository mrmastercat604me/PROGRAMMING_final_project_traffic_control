Flow Free-style Puzzles:
Gameplay:
Create grids where players connect pairs of tiles of the same color with non-intersecting paths.

Challenge:
Procedurally generate puzzles where the paths should be challenging,
but not too predictable. The key is ensuring that multiple paths can exist,
but some are blocked or forced to take certain turns.

What you can use:
A* pathfinding can help ensure paths are solvable.
Random obstacles and varying grid sizes can make it more interesting.

Labyrinth Solver:
Gameplay:
Generate random mazes, and the player’s task is to find a path from start to finish.

Challenge:
You can create time challenges, shifting mazes,
or have “rooms” that need to be solved in sequence.

What you can use:
A* can help the AI or the player find a path.
Adding environmental elements like walls that shift or traps can create more engaging puzzles.

What if we combine them?
You could design a labyrinth-style puzzle where the grid is filled with flow-style paths.
The player could be tasked with solving multiple path pairs in the maze, making it more engaging.

The maze could have parts that are already solved,
or maybe parts that randomly block paths and change with time.

As the player progresses, the puzzle could shift or have new rules added—for example,
you can make paths block certain tiles temporarily.


# MAZE GENERATION
CORRIDORS
LOTS OF INTERCONNECTIVTY 
VARIABLE WIDTHS OF CORRIDORS
SMALL POCKETS OF ROUNDABOUTS

==============================
- BASE MAZE USING RANDOM DFS
- RANDOM INSERTS OF ROUNDABOUTS
- WIDEN SOME CORRIDORS
- ADD EXRA INTERCONNECTIVITY



'''
function generate_maze(width, height):
    // Width and height are logical maze cells, not full grid
    grid_width = width * 2 + 1
    grid_height = height * 2 + 1
    maze = 2D array of size (grid_height x grid_width), filled with WALL (O)

    function carve(x, y):
        maze[y][x] = PATH (P)
        directions = shuffle([(0, -2), (2, 0), (0, 2), (-2, 0)])  // NESW

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if in_bounds(nx, ny) and maze[ny][nx] == WALL:
                // Carve passage through wall between
                maze[y + dy // 2][x + dx // 2] = PATH
                carve(nx, ny)

    // Start at (1,1)
    carve(1, 1)
    return maze
'''