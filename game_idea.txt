Flow Free-style Puzzles:
Gameplay:
Create grids where players connect pairs of tiles of the same color with non-intersecting paths.

Challenge:
Procedurally generate puzzles where the paths should be challenging,
but not too predictable. The key is ensuring that multiple paths can exist,
but some are blocked or forced to take certain turns.

What you can use:
A* pathfinding can help ensure paths are solvable.
Random obstacles and varying grid sizes can make it more interesting.

Labyrinth Solver:
Gameplay:
Generate random mazes, and the player’s task is to find a path from start to finish.

Challenge:
You can create time challenges, shifting mazes,
or have “rooms” that need to be solved in sequence.

What you can use:
A* can help the AI or the player find a path.
Adding environmental elements like walls that shift or traps can create more engaging puzzles.

What if we combine them?
You could design a labyrinth-style puzzle where the grid is filled with flow-style paths.
The player could be tasked with solving multiple path pairs in the maze, making it more engaging.

The maze could have parts that are already solved,
or maybe parts that randomly block paths and change with time.

As the player progresses, the puzzle could shift or have new rules added—for example,
you can make paths block certain tiles temporarily.


# REVISI THIS IDEA LATER WITH BETTER QUESTION
HOW CAN I MAKE A MAX NUMBER OF PATH TILES IN A REGION? SO THAT THERE IS FOR SURE MULTIPLE WAYS TO GET FROM TWO CONNECTED REGIONS TO TWO CONNECTED REGIONS?



def create_path(grid, start, end):
    x1, y1 = start
    x2, y2 = end
    path_tiles = []

    ...

    # Go horizontal first, then vertical
    for x in range(min(x1, x2), max(x1, x2) + 1):
        tile = grid.get_tile_with_index(x, y1)
        tile.type = 'path'
        path_tiles.append((x, y1))

    for y in range(min(y1, y2), max(y1, y2) + 1):
        tile = grid.get_tile_with_index(x2, y)
        tile.type = 'path'
        path_tiles.append((x2, y))
    
    return path_tiles
